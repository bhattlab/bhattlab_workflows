import os,re

'''
Aim: A simple wrapper for metagenomics QC using paired end reads. To use this pipeline, edit parameters in the config.yaml, and specify the proper path to config file in the submission script.

This program runs under the assumption samples are named:
PREFIX_R1.fastq.gz and PREFIX_R2.fastq.gz.

This script will create the following folders:
PROJECT_DIR/qc/00_qc_reports/pre_fastqc
PROJECT_DIR/qc/00_qc_reports/post_fastqc
PROJECT_DIR/qc/01_trimmed
PROJECT_DIR/qc/02_dereplicate
PROJECT_DIR/qc/03_interleave
'''

################################################################################
# specify project directories
DATA_DIR    = config["raw_reads_directory"]
PROJECT_DIR = config["output_directory"]

################################################################################
# get the names of the files in the directory
FILES = [f for f in os.listdir(DATA_DIR) if f.endswith(tuple(['fastq.gz', 'fq.gz']))]
SAMPLE_PREFIX = list(set([re.split('_1|_2', i)[0] for i in FILES]))

################################################################################
# specify which rules do not need to be submitted to the cluster
localrules:  interleave

rule all:
	input:
		expand(os.path.join(PROJECT_DIR, "/00_qc_reports/pre_fastqc/{sample}_R{read}_fastqc.html"), 
		      , sample=SAMPLE_PREFIX),
		expand(os.path.join(PROJECT_DIR, "qc/00_qc_reports/post_fastqc/{sample}_nodup_PE{read}_fastqc.html"), 
		      , sample=SAMPLE_PREFIX)
		expand(os.path.join(PROJECT_DIR, "qc/03_interleave/{sample}.fastq"), sample=SAMPLE_PREFIX)

################################################################################
rule pre_fastqc:
	input:  os.path.join(DATA_DIR, "{sample}_R{read}.fastq.gz")
	output: os.path.join(PROJECT_DIR,  "qc/00_qc_reports/pre_fastqc/{sample}_R{read}_fastqc.html")
	threads: 1
	shell: """
	   mkdir -p {PROJECT_DIR}/qc/00_qc_reports/pre_fastqc/
	   # module load java/latest
	   # module load fastqc/0.11.2
	   fastqc {input} --outdir {PROJECT_DIR}/qc/00_qc_reports/pre_fastqc/
	"""
		
################################################################################
rule post_fastqc:
	input:  rules.dereplicate.output
	output: os.path.join(PROJECT_DIR,  "qc/00_qc_reports/post_fastqc/{sample}_nodup_PE{read}_fastqc.html")
	threads: 1
	log: os.path.join(LOGS_DIR + "post_fastqc_{sample}_R{read}")
	shell: """
	   mkdir -p {PROJECT_DIR}/qc/00_qc_reports/post_fastqc/
	   # module load fastqc/0.11.2
	   fastqc {input} -f fastq --outdir {PROJECT_DIR}/qc/00_qc_reports/post_fastqc/
	 """		

################################################################################
rule check_mutliplex_issues:
	
## Eli
		
################################################################################
rule trim_galore:
	input:
		fwd = os.path.join(DATA_DIR, "{sample}_1.fastq.gz"),
		rev = os.path.join(DATA_DIR, "{sample}_2.fastq.gz")
	output:
		fwd = os.path.join(PROJECT_DIR, "qc/01_trimmed/{sample}_1_val_1.fq.gz"),
		rev = os.path.join(PROJECT_DIR, "qc/01_trimmed/{sample}_2_val_2.fq.gz")
	threads: 4
	params:
		adaptor = config['trim_galore']['adaptors'],
		q_min   = config['trim_galore']['quality']
		left    = config['trim_galore']['start_trim']
		min_len = config['trim_galore']['min_read_length']
	shell: """
		 mkdir -p {PROJECT_DIR}/qc/01_trimmed/
		 trim_galore --{params.adaptor} \
			     --quality {params.q_min} \
			     --clip_R1 {params.left} --clip_R2 {params.left} \
			     --length {params.min_len} \
			     --output_dir {PROJECT_DIR}/qc/01_trimmed/ \
			     --paired {input.fwd} {input.rev}
	"""

################################################################################
rule dereplicate:
	input:
	 	fwd = rules.trim_galore.output.fwd,
		rev = rules.trim_galore.output.rev
	output:
	 	fwd = os.path.join(PROJECT_DIR, "qc/02_dereplicate/{sample}_nodup_PE1.fastq"),
		rev = os.path.join(PROJECT_DIR, "qc/02_dereplicate/{sample}_nodup_PE2.fastq")
	threads: 2
	shell: """
		mkdir -p {PROJECT_DIR}/qc/02_dereplicate/
		seqtk rmdup {input.fwd} > {output.fwd}
		seqtk rmdup {input.rev} > {output.rev}
	"""


################################################################################
rule interleave:
	input:  rules.dereplicate.output
	output: os.path.join(PROJECT_DIR, "qc/03_interleave/{sample}.fastq")
	shell: """
		# Eli's Python script and command line options
	"""

################################################################################
rule remove_host_reads:
	input: rules.interleave.output
	output:
	params:
		host_genome = config['rm_host_reads']['host_genome']
	shell: """
	# reference alignment to specified host
	# Wh
		
	"""	

		
		
